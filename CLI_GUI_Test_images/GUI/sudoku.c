/*******************************************************************************
*
*   FILE:           sudoku_generator.c
*
*   DESCRIPTION:    This C program generates a solvable Sudoku puzzle of medium
*                   difficulty. It first creates a fully solved grid and then
*                   removes a specified number of digits while ensuring a
*                   single unique solution is maintained.
*
*                   After displaying the puzzle, the program will wait for the
*                   user to press the Enter key before revealing the solution.
*
*                   DIFFICULTY ADJUSTMENT:
*                   The difficulty is controlled by the second argument passed
*                   to the `removeNumbers()` function in `main()`. A higher
*                   number means more digits are removed, which generally
*                   results in a more challenging puzzle.
*
*                   - removeNumbers(grid, 40); // Easier
*                   - removeNumbers(grid, 50); // Medium
*                   - removeNumbers(grid, 60); // Harder
*
*   AUTHOR:         Generated by Gemini, Google's AI
*
*   DATE:           October 2, 2025
*
********************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define N 9
#define UNASSIGNED 0

// Function Declarations
void generateSudoku(int grid[N][N]);
int  solveSudoku(int grid[N][N]);
void removeNumbers(int grid[N][N], int difficulty);
int  countSolutions(int grid[N][N]);
void printGrid(int grid[N][N]);
int  findUnassignedLocation(int grid[N][N], int* row, int* col);
int  isSafe(int grid[N][N], int row, int col, int num);


int main() 
{
    int grid[N][N] = { 0 };
    int solutionGrid[N][N]; // Array to store the full solution
    srand(time(0));

    // 1. Generate a complete Sudoku solution
    generateSudoku(grid);

    // 2. Save the complete solution before removing numbers
    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < N; j++)
        {
            solutionGrid[i][j] = grid[i][j];
        }
    }

    // 3. Remove numbers to create the puzzle
    removeNumbers(grid, 50);

    // 4. Print the generated puzzle
    printf("Generated Medium Difficulty Sudoku Puzzle:\n");
    printGrid(grid);

    // 5. Prompt user and wait for input before showing the solution
    printf("\nPress Enter to reveal the solution...");
    getchar(); // Waits for the user to press the Enter key

    // 6. Print the saved solution
    printf("\n\nSolution:\n");
    printGrid(solutionGrid);

    return 0;
}

// Generates a full Sudoku board by solving an empty one
void generateSudoku(int grid[N][N]) 
{
    solveSudoku(grid);
}

// Finds the first unassigned (0) location in the grid
int findUnassignedLocation(int grid[N][N], int* row, int* col) 
{
    for (*row = 0; *row < N; (*row)++) 
    {
        for (*col = 0; *col < N; (*col)++)
        {
            if (grid[*row][*col] == UNASSIGNED)
            {
                return 1;
            }
        }
    }

    return 0;
}

// Checks if a number is already used in a row
int usedInRow(int grid[N][N], int row, int num) 
{
    for (int col = 0; col < N; col++)
    {
        if (grid[row][col] == num)
        {
            return 1;
        }
    }

    return 0;
}

// Checks if a number is already used in a column
int usedInCol(int grid[N][N], int col, int num)
{
    for (int row = 0; row < N; row++) 
    {
        if (grid[row][col] == num)
        {
            return 1;
        }
    }

    return 0;
}

// Checks if a number is already used in a 3x3 box
int usedInBox(int grid[N][N], int boxStartRow, int boxStartCol, int num) 
{
    for (int row = 0; row < 3; row++) 
    {
        for (int col = 0; col < 3; col++) 
        {
            if (grid[row + boxStartRow][col + boxStartCol] == num) 
            {
                return 1;
            }
        }
    }

    return 0;
}

// Checks if it is safe to place a number in a given cell
int isSafe(int grid[N][N], int row, int col, int num) 
{
    return !usedInRow(grid, row, num) &&
        !usedInCol(grid, col, num) &&
        !usedInBox(grid, row - row % 3, col - col % 3, num) &&
        grid[row][col] == UNASSIGNED;
}

// Solves the Sudoku using a randomized backtracking algorithm
int solveSudoku(int grid[N][N]) 
{
    int row, col;

    if (!findUnassignedLocation(grid, &row, &col))
    {
        return 1; // Puzzle is solved
    }

    int nums[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
    // Randomize the numbers to try, creating different puzzles each time
    for (int i = 0; i < N; i++) 
    {
        int j = rand() % N;
        int temp = nums[i];
        nums[i]  = nums[j];
        nums[j]  = temp;
    }

    for (int i = 0; i < N; i++) 
    {
        int num = nums[i];
        if (isSafe(grid, row, col, num)) 
        {
            grid[row][col] = num;

            if (solveSudoku(grid))
            {
                return 1;
            }

            grid[row][col] = UNASSIGNED; // Backtrack
        }
    }

    return 0;
}

// Removes 'count' numbers from a full grid to create a puzzle
void removeNumbers(int grid[N][N], int count) 
{
    while (count > 0) {
        int row = rand() % N;
        int col = rand() % N;

        if (grid[row][col] != UNASSIGNED) 
        {
            int temp = grid[row][col];
            grid[row][col] = UNASSIGNED;

            int tempGrid[N][N];
            for (int i = 0; i < N; i++) 
            {
                for (int j = 0; j < N; j++)
                {
                    tempGrid[i][j] = grid[i][j];
                }
            }

            if (countSolutions(tempGrid) != 1) 
            {
                // If removing the number makes the puzzle have non-unique solutions,
                // put it back.
                grid[row][col] = temp;
            }
            else 
            {
                count--;
            }
        }
    }
}

// Counts the number of solutions for a given grid state
int countSolutions(int grid[N][N]) {
    int row, col;
    int count = 0;

    if (!findUnassignedLocation(grid, &row, &col)) 
    {
        return 1; // A solution is found
    }

    for (int num = 1; num <= 9; num++) 
    {
        if (isSafe(grid, row, col, num)) 
        {
            grid[row][col] = num;
            count += countSolutions(grid);
            grid[row][col] = UNASSIGNED; // Backtrack
        }
    }

    return count;
}

// Prints the Sudoku grid in a formatted way
void printGrid(int grid[N][N]) 
{
    for (int row = 0; row < N; row++)
    {
        if (row % 3 == 0 && row != 0)
        {
            printf("---------------------\n");
        }

        for (int col = 0; col < N; col++) 
        {
            if (col % 3 == 0 && col != 0) 
            {
                printf("| ");
            }

            if (grid[row][col] == UNASSIGNED) 
            {
                printf(". ");
            }
            else 
            {
                printf("%d ", grid[row][col]);
            }
        }
        printf("\n");
    }
}